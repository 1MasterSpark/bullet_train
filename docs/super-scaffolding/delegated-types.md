# Super Scaffolding with Delegated Types

## Introduction
In this guide, we‚Äôll cover how to use Super Scaffolding to build views and controllers around models leveraging delegated types. As a prerequisite, you should read the [native Rails documentation for delegated types](https://edgeapi.rubyonrails.org/classes/ActiveRecord/DelegatedType.html). The examples in that documentation only deal with using delegated types at the Active Record level, but they lay a foundation that we won‚Äôt be repeating here.

## Terminology
For the purposes of our discussion here, and building on the Rails example, we‚Äôll call their `Entry` model the **‚ÄúAbstract Parent‚Äù** and the `Message` and `Comment` models the **‚ÄúConcrete Children‚Äù**.

## One of Multiple Approaches
It‚Äôs worth noting there are at least two different approaches you can take for implementing views and controllers around models using delegated types:

1. Centralize views and controllers around the Abstract Parent (e.g. `Account::EntriesController`).
2. Create separate views and controllers for each Concrete Child (e.g. `Account::MessagesController`, `Account::CommentsController`, etc.)

**In this guide, we‚Äôll be covering the first approach.** This might not seem like an obvious choice for the `Message` and `Comment` examples we‚Äôre drawing on from the Rails documentation (it's not), but it is a very natural fit for other common use cases like:

 - ‚ÄúI‚Äôd like to add a field to this form and there are many kinds of fields.‚Äù
 - ‚ÄúI‚Äôd like to add a section to this page and there are many kinds of sections.‚Äù

It‚Äôs not to say you can‚Äôt do it the other way, but this approach has specific benefits:

1. It‚Äôs a lot less code. We only have to use Super Scaffolding for the Abstract Parent. It's the only model with views and controllers generated. For the Concrete Children, the only files required are the models, tests, and migratiosn generated by `rails g model` and some locale Yaml files for each Concrete Child.
2. Controller permissions can be enforced the same way they always are, by checking the relationship between the Abstract Parent (e.g. `Entry`) and `Team`. All permissions are defined in `app/models/ability.rb` around `Entry`, instead of each Concrete Child.

## Steps

### 1. Generate Rails Models

Drawing on the [canonical Rails example](https://edgeapi.rubyonrails.org/classes/ActiveRecord/DelegatedType.html), we begin by using Rails' native model generators:

```
rails g model Entry team:references entryable:references{polymorphic}:index
rails g model Message subject:string
rails g model Comment content:text
```

Note that in this specific approach we don't need a `team:references` on `Message` and `Comment`. That's because in this approach there are no controllers specific to `Message` and `Comment`, so all permissions are being inforced by checking the ownership of `Entry`. (That's not to say it would be wrong to add them for other reasons, we're just keeping it as simple as possible here.)

### 2. Super Scaffolding for `Entry`

```
bin/super-scaffold crud Entry Team entryable_type:buttons
```

We use `entryable_type:buttons` because we're going to allow people to choose which type of `Entry` they're creating with a list of buttons. This isn't the only option available to us, but it's the easiest to implement for now.

### 3. Defining Button Options

Super Scaffolding will have generated some initial button options for us already in `config/locales/en/entries.en.yml`. We'll want to update the attribute `name`, field `label` (which is shown on the form) and the available options to reflect the available Concrete Children like so:

```
fields: &fields
  entryable_type:
    name: &entryable_type Entry Type
    label: What type of entry would you like to create?
    heading: *entryable_type
    options:
      "Message": Message
      "Comment": Comment
```

<small>TODO Insert a live example of what `shared/fields/buttons` looks like with these options passed in.</small>

### 4. Add Our First Step to `new.html.erb`

By default, `app/views/account/entries/new.html.erb` has this reference to the shared `_form.html.erb`:

```
<%= render 'form', entry: @entry %>
```

However, in this workflow we actually need two steps:

1. Ask the user what type of entry they're creating.
2. Show the user the entry form with the appropriate fields for the type of entry they're creating.

The first of these two forms is actually not shared between `new.html.erb` and `edit.html.erb`, so copying the contents of `_form.html.erb` as a starting point, we'll define it directly in `new.html.erb` like so:

```
<% if @entry.entryable_type %>
  <%= render 'form', entry: @entry %>
<% else %>
  <%= form_with model: @entry, url: [:new, :account, @team, :entry], method: :get, local: true, class: 'form' do |form| %>
    <%= render 'account/shared/forms/errors', form: form %>
    <% with_field_settings form: form do %>
      <%= render 'shared/fields/buttons', method: :entryable_type, html_options: {autofocus: true} %>
    <% end %>
    <div class="buttons">
      <%= form.submit t('.buttons.next'), class: "button" %>
      <%= link_to t('global.buttons.cancel'), [:account, @team, :entries], class: "button-secondary" %>
    </div>
  <% end %>
<% end %>
```

Here's a summary of the updates required when copying `_form.html.erb` into `new.html.erb`:

1. Add the `if @entry.entryable_type` branch logic, maintaining the existing reference to `_form.html.erb`.
2. Add `@` to the `entry` references throughout. `@entry` is an instance variable in this view, not passed in as a local.
3. Update the form submission `url` and `method` as seen above.
4. Remove the Super Scaffolding hooks. Any additional fields that we add to `Entry` would be on the actual `_form.html.erb`, not this step.
5. Simplify button logic because the form is always for a new object.

### 5. Update Locales

We need to add a locale entry for the "next" button in `config/locales/en/entries.en.yml`. This goes under the `buttons: &buttons` entry that is already present, like so:

```
buttons: &buttons
  next: Next Step
```

Also, sadly, the original locale file wasn't expecting any buttons in `new.html.erb` directly, so we need to include buttons on this page under `new` in the same file, below `form: *form`, like so:

```
new:
  # ...
  form: *form
  buttons: *buttons
```

### 6. Add Appropriate Validations in `entry.rb`

In `app/models/entry.rb`, we want to update the validation of `entryable_type` like so:

```
  validates :entryable_type, presence: true, inclusion: { in: I18n.t('entries.fields.entryable_type.options').keys.map(&:to_s) }
```

This makes the locale file, where we define the options to present to the user, the single source of truth for what the valid options are.

<small>TODO We should look into whether reflecting on the definition of the delegated types is possible.</small>

Also, to make it easy to check the state of this validation, we'll add `entryable_type_valid?` as well:

```
def entryable_type_valid?
  if entryable_type.present?
    valid?
    result = errors[:entryable_type].empty?
    errors.clear
    return result
  end
end
```

I don't like this method. If you can think of a way to get rid of it or write it better, please let us know!

### 7. Populate `@entry.entryable` in `entries_controller.rb`

To prepare for presenting the second step to users, we need to initialize either a `Message` or `Comment` object and associate `@entry` with it, in the `new` action of `app/controllers/account/entries_controller.rb`, like so:

```
def new
  if @entry.entryable_type_valid?
    @entry.entryable = @entry.entryable_type.constantize.new
  end
end
```

We use `constantize` here because we've checked that `entryable_type` is valid and therefore safe.

### 8. Accept Nested Attributes in `entry.rb` and `entries_controller.rb`

We need to configure `Entry` to accept [nested attributes](https://edgeapi.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html). We do this in two places:

First, in `app/models/entry.rb`, like so:

```
accepts_nested_attributes_for :entryable
```

Then, also add the following method definition in the model:

```
def build_entryable(params)
  raise 'invalid entryable type' unless entryable_type_valid?
  self.entryable = entryable_type.constantize.new(params)
end
```

Finally, in the [strong parameters](https://edgeguides.rubyonrails.org/action_controller_overview.html#strong-parameters) of `app/controllers/account/entries_controller.rb`, _below_ this line:

```
# üöÖ super scaffolding will insert new arrays above this line.
```

But still within the `permit` parameters, add:

```
entryable_attributes: [
  :id,

  # Message attributes:
  :subject,

  # Comment attributes:
  :content,
],
```

This is an example of what I meant when I said this approach is "less code": All attributes for all the Concrete Children are specified in a single controller. (There is, however, an edge case if you want to specify the same attribute name as being permissible for one Concrete Child model while not being permissible for another.)

### 9. Add Fields for Concrete Children to Second Step in `_form.html.erb`

Since we're now prompting for the entry type on the first step, we can remove the following from the second step in `app/views/account/entries/_form.html.erb`:

```
<%= render 'shared/fields/buttons', method: :entryable_type, html_options: {autofocus: true} %>
```

But we need to keep track of which entry type they selected, so we replace it with:

```
<%= form.hidden_field :entryable_type %>
```

Also, below that (and below the Super Scaffolding hook), we want to add the `Message` and `Comment` fields as [nested attributes](https://edgeapi.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html) like so:

```
<%= form.fields_for entry.entryable do |entryable_form| %>
  <%= entryable_form.hidden_field :id %>
  <% with_field_settings form: entryable_form do %>
    <% case entryable_form.object %>
    <% when Message %>
      <%= render 'shared/fields/text_field', method: :subject, options: {autofocus: true} %>
    <% when Comment %>
      <%= render 'shared/fields/ckeditor', method: :content, options: {autofocus: true} %>
    <% end %>
  <% end %>
<% end %>
```

We add this _below_ the Super Scaffolding hook because we want any additional fields being added to `Entry` directly to appear in the form _above_ the nested form fields.

### 10. Add Attributes of the Concrete Children to `show.html.erb` for `Entry`

Under the Super Scaffolding hook in `app/views/account/entries/show.html.erb`, add the following:

```
<% with_attribute_settings object: @entry.entryable, strategy: :label do %>
  <% case @entry.entryable %>
  <% when Message %>
    <%= render 'shared/attributes/text', attribute: :subject %>
  <% when Comment %>
    <%= render 'shared/attributes/html', attribute: :content %>
  <% end %>
<% end %>
```

This will ensure the various different attributes of the Concrete Children are properly presented. However, the `label` strategy for these attribute partials depend on the locales for the individual Concrete Children being defined, so we need to create those files now, as well:

`config/locales/en/messages.en.yml`:
```
en:
  messages: &messages
    fields:
      subject:
        _: &subject Subject
        label: *subject
        heading: *subject
  account:
    messages: *messages
  activerecord:
    attributes:
      message:
        subject: *subject
```

`config/locales/en/comments.en.yml`:
```
en:
  comments: &comments
    fields:
      content:
        _: &content Content
        label: *content
        heading: *content
  account:
    comments: *comments
  activerecord:
    attributes:
      comment:
        content: *content
```

### 11. Actually Use Delegated Types?

So everything should now be working as expected, and here's the crazy thing: We haven't even used the delegated types feature yet. That was the beauty of delegated types when it was released in Rails 6.1. It was really a formalization of an approach that folks had already been doing in Rails for years.

<center>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Really loving the PR for Rails 6.1&#39;s Delegated Types. From the application developer level, very little of it feels &quot;new&quot;. Instead, the experience reads very similar to what many of us were already doing with the existing tools, but even smoother! <a href="https://t.co/6UkxXNCvaa">https://t.co/6UkxXNCvaa</a></p>&mdash; Andrew Culver (@andrewculver) <a href="https://twitter.com/andrewculver/status/1338189146213543951?ref_src=twsrc%5Etfw">December 13, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

To now incorporate delegated types as put forward in the original documentation, we want to remove this line in `app/models/entry.rb`:

```
belongs_to :entryable, polymorphic: true
```

And replace it with:

```
delegated_type :entryable, types: %w[ Message Comment ]
```

We also want to follow the other steps seen there, such as defining `Entryable` in `app/models/entryable.rb`, like so:

```
module Entryable
  extend ActiveSupport::Concern

  included do
    has_one :entry, as: :entryable, touch: true
  end
end
```

And including the `Entryable` module in both `app/models/message.rb` and `app/models/comment.rb` like so:

```
include Entryable
```

That's it! You're done!
